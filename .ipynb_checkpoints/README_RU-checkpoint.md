# HashMap
| [ENG](https://github.com/A1eksMa/HashMap/blob/main/README.md) | [RU](https://github.com/A1eksMa/HashMap/blob/main/README_RU.md) | 

## Практика в Java. Пишем свой собственный HashMap Collections Framework.
См. [ENG](https://github.com/A1eksMa/HashMap/blob/main/README.md) версию.

### Введение
Это учебный проект, попытка написать свою собственную коллекцию на базе Java Collections Framework. Цели проекта - получить практику в написании ООП кода на Java, поглубже разобраться в API Collections Framework. Итоговая задача - написать немного упрощенный HashMap, или коллекцию, близкую к нему по своему поведению и структуре.

### Описание структуры данных:
 - на верхнем уровне: нативный массив Java, с начальной длиной `len`.  
 - на следующем уровне, элементы массива - бакеты - содержат ноды организованные в виде:
   - либо односвязанного списка,
   - либо дерева.
В составе каждой ноды содержится: хэш ключа `h`, ключ `k`, значение `v`.
Количество нод в бакете обозначим за `n`, количество нод во всех бакетах - за `sum(n)` (здесь и далее).

### Начальное состояние:
1. Пусть начальная длина массива (количество бакетов)
```java
    int len = 2;
```
2. Начальный тип элемента в бакете - односвязанный список с 0 элементов.
3. Внутренняя константа порогового значения `Q` (для упрощения примем ее единой для всех случаев порога изменения). Для примера, будем использовать
```java
   int `Q` = 128;
```

### Полученная структура должна обладать следующим поведением:
1. Массив верхней структуры должен динамически удваивать свою длину, в случаях когда соотношении общего количества нод `sum(n)` к длине массива `len` достигает порогового значения `Q`.

Условие перехода к удвоению длины массива:
```java
    if (sum(n) / len > Q) {}
```

2. Тип элемента бакета должен изменяться с односвязанного списка на дерево при превышении количеством элементов в бакете `n` порогового значения `Q`.

Условие перестроения способа организации нод в бакете (с односвязанного списка на дерево):
```java
    if (n > Q) {}
```

3. При добавлении элемента `e` в массив, выбор бакета (индекса `i` массива верхнего уровня) происходит на основании рассчитаного хэша элемента:
```java
   h = e.hashCode()
```
по формулам:
    d = (max_int - min_int + 1)
    i = (h - min_int) / ( d / len )

где:
    i - индекс массива (он же - номер бакета);
    d - количество возможных значений хэша;
    max_int - максимально возможное значение хэша, 2_147_483_647;
    min_int - минимально возможное значение хэша, -2_147_483_648;


